## 1. 문제요약
- 5가지의 테트로미노가 존재한다.
- N*M 종이 위에 숫자가 써져 있다.
- "딱 1개" 테트로미노 놓을 시 칸의 최대 합을 구하라.
- 테트로미노를 회전/대칭 시키는 것이 가능하다.
- 각 칸에 정확히 테트로미노가 올라가야 한다.

## 2. 입출력
### [입력]
- N,M (4<=N,M<=500) 
- 종이의 입력칸은 1000을 넘지 않는다. 

## 3. 알고리즘
- 정사각형 4개를 이어붙였다. 즉 각 칸에 대해서 면적 4개를 채웠을 때 최대 합을 DFS로 찾는다.
- 최대합을 기록하고, 시작점 칸은 VISIT 처리.
- ㅓ,ㅏ,ㅗ,ㅜ 모양은 dfs로 발견 불가. 따로 처리해줌


### 3.1 특수모양(ㅏ,ㅓ,ㅗ,ㅜ) 처리
- 현재 칸 i,j를 기준으로 상하좌우의 값을 모두 더함.
- 더할 수 있었던 상하좌우의 카운팅을 표시. 
  - 카운팅 3일 시 해당 값이 최대의 값
  - 카운팅 4일 시 상하좌우 값 중 가장 작은 수를 뺀 게 최대의 값


### 3.2 dfs 최적화
- 입력 받을 시, 가장 큰 값(maxCell) 기록
- DFS 탐색 중 현재까지 선택한 블록 개수를 기준으로, 앞으로 더 선택해야 할 블록 수(remain = 4 - depth)를 계산.
- 앞으로 남은 블록에서 나올 수 있는 최대합은 sum + remain × maxCell 이 된다. 
- 만약 이 값 <= 이미 구해진 최대 합 일 시, DFS 즉시 종료

